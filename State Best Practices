**Practical Guidelines for Using State**
Now, to conclude, here are some practical guidelines on how to use state effectively. These guidelines also serve as a summary of state concepts.

- Create a new state variable for any data that a component should track over time. A simple way to identify this is to consider variables that need to change at some point in the future.
- If you are familiar with building apps in Vanilla JavaScript, these are variables defined with "let" or "var", or arrays or objects that are mutated during the application's lifecycle. In React, you use state for these.
- Whenever you want something in a component to be dynamic, create a piece of state related to that "thing" and update the state when the "thing" should change, meaning when you need it to be dynamic.

For instance, consider a modal window that can be either open or closed. You can create a state variable called "isOpen" to track whether the modal is currently open. When "isOpen" is true, display the window; if false, hide it.

- Whenever you want to change how a component looks or the data it displays, update its state, usually inside an event handler function.
- When building components, always imagine the component's view as a reflection of state changing and evolving over time.
- Avoid using state for every variable in a component. Use state only for variables that should trigger a re-render. For variables that do not require re-rendering, use regular variables defined with "const" to prevent unnecessary re-renders and potential performance issues.

This first set of guidelines about state should be more than enough for now. Internalizing these concepts will make building React applications much easier in the future.

Mastering state is the most challenging part of learning React, but once you overcome this hurdle and truly understand when and how to use state, it will unlock React development for you. This is why so much time has been dedicated to explaining how state works.

**Key Takeaways**
Each component instance manages its own independent state.
The entire user interface can be viewed as a function of all component states.
State should be used for data that changes over time and affects the UI dynamically.
Avoid using state for variables that do not require re-rendering to prevent performance issues.

**STATE**
//_ STATE is Internal data, owned by component, think of it as memory
//_ are updated by component itself
//_ updating state causes a re-render
//_ used to make components interactive

**PROPS**
//_ PROPS is External data owned by the parent component
//_ (also known as function parameters from a purely js point of view)
//_ are read-only (in react, but not so in Angular)
//_ recieving new props causes component to re-render (usually when parent's state is updated)
//\* used by parent to configure child component (aka pass it "settings")

**THINKING IN REACT as a process**

// 1. break desired UI into components and establish a component tree
// 2. build a static version in react (witout state)
// 3. think about state [statemanagement]:
/// 3.1 when to use state,
/// 3.2 types of state [local vs global],
/// 3.3 where to place each piece of state
// 4. establish data flow [statemanagement]:
/// 4.1 one-way data flow
/// 4.2 child-to-parent communication
/// 4.3 Accessing global state

\* State is the most important concept in React. Therefore, managing state is the most important aspect when it comes to thinking in React.

**Benefits of Mastering Thinking in React**
Once you truly know how to think in React, you will be able to answer questions such as:

- How to break up a UI design into components.
- How to make some components truly reusable.
- How to assemble a user interface from reusable components.
- what pieces of state do i need for interactivty
- where to place state?
- what types of state can or should be used
- how to make data flow through the app
  You will also think extensively about state, including what pieces of state are needed for the desired interactivity, where to place each piece of state, and which component should own each piece of state.

<!-- State Managment -->

- when
- type
- where
- data flow

basically \* give each piece of data a home

Local STATE VS Global State
state need only by one or few components ||
